{-
    BNF Converter: Pretty-printer generator
    Copyright (C) 2004  Author:  Aarne Ranta

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-}

module BNFC.Backend.Haskell.CFtoPrinter (cf2Printer) where

import BNFC.Backend.Haskell.Utils (hsReservedWords)
import BNFC.CF
import BNFC.Utils
import Data.Either (lefts)
import Data.Char(toLower)
import Text.PrettyPrint

-- derive pretty-printer from a BNF grammar. AR 15/2/2002
cf2Printer :: Bool -> Bool -> Bool -> String -> String -> CF -> String
cf2Printer byteStrings functor pos name absMod cf = unlines [
  prologue byteStrings name absMod,
  integerRule cf,
  doubleRule cf,
  if hasIdent cf then identRule byteStrings cf else "",
  unlines [ownPrintRule byteStrings cf own | (own,_) <- tokenPragmas cf],
  rules functor pos cf
  ]


prologue :: Bool -> String -> String -> String
prologue byteStrings name absMod = unlines [
  "{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}",
  "module " ++ name +++ "where\n",
  "-- pretty-printer generated by the BNF converter\n",
  "import " ++ absMod,
  "import Data.Char",
  (if byteStrings then "import qualified Data.ByteString.Char8 as BS" else ""),
  "",
  "-- the top-level printing method",
  "printTree :: Print a => a -> String",
  "printTree = render . prt 0",
  "",
  "type Doc = [ShowS] -> [ShowS]",
  "",
  "doc :: ShowS -> Doc",
  "doc = (:)",
  "",
  "render :: Doc -> String",
  "render d = rend 0 (map ($ \"\") $ d []) \"\" where",
  "  rend i ss = case ss of",
  "    \"[\"      :ts -> showChar '[' . rend i ts",
  "    \"(\"      :ts -> showChar '(' . rend i ts",
  "    \"{\"      :ts -> showChar '{' . new (i+1) . rend (i+1) ts",
  "    \"}\" : \";\":ts -> new (i-1) . space \"}\" . showChar ';' . new (i-1) . rend (i-1) ts",
  "    \"}\"      :ts -> new (i-1) . showChar '}' . new (i-1) . rend (i-1) ts",
  "    \";\"      :ts -> showChar ';' . new i . rend i ts",
  "    t  : \",\" :ts -> showString t . space \",\" . rend i ts",
  "    t  : \")\" :ts -> showString t . showChar ')' . rend i ts",
  "    t  : \"]\" :ts -> showString t . showChar ']' . rend i ts",
  "    t        :ts -> space t . rend i ts",
  "    _            -> id",
  "  new i   = showChar '\\n' . replicateS (2*i) (showChar ' ') . dropWhile isSpace",
  "  space t = showString t . (\\s -> if null s then \"\" else (' ':s))",
  "",
  "parenth :: Doc -> Doc",
  "parenth ss = doc (showChar '(') . ss . doc (showChar ')')",
  "",
  "concatS :: [ShowS] -> ShowS",
  "concatS = foldr (.) id",
  "",
  "concatD :: [Doc] -> Doc",
  "concatD = foldr (.) id",
  "",
  "replicateS :: Int -> ShowS -> ShowS",
  "replicateS n f = concatS (replicate n f)",
  "",
  "-- the printer class does the job",
  "class Print a where",
  "  prt :: Int -> a -> Doc",
  "  prtList :: [a] -> Doc",
  "  prtList = concatD . map (prt 0)",
  "",
  "instance Print a => Print [a] where",
  "  prt _ = prtList",
  "",
  "instance Print Char where",
  "  prt _ s = doc (showChar '\\'' . mkEsc '\\'' s . showChar '\\'')",
  "  prtList s = doc (showChar '\"' . concatS (map (mkEsc '\"') s) . showChar '\"')",
  "",
  "mkEsc :: Char -> Char -> ShowS",
  "mkEsc q s = case s of",
  "  _ | s == q -> showChar '\\\\' . showChar s",
  "  '\\\\'-> showString \"\\\\\\\\\"",
  "  '\\n' -> showString \"\\\\n\"",
  "  '\\t' -> showString \"\\\\t\"",
  "  _ -> showChar s",
  "",
  "prPrec :: Int -> Int -> Doc -> Doc",
  "prPrec i j = if j<i then parenth else id",
  ""
  ]

integerRule cf = showsPrintRule cf "Integer"
doubleRule cf = showsPrintRule cf "Double"

showsPrintRule cf t = unlines $ [
  "instance Print " ++ t ++ " where",
  "  prt _ x = doc (shows x)",
  ifList cf (Cat t)
  ]

identRule byteStrings cf = ownPrintRule byteStrings cf catIdent

ownPrintRule byteStrings cf own = unlines $ [
  "instance Print " ++ show own ++ " where",
  "  prt _ (" ++ show own ++ posn ++ ") = doc (showString ("++stringUnpack++" i))",
  ifList cf own
  ]
 where
   posn = if isPositionCat cf own then " (_,i)" else " i"

   stringUnpack | byteStrings = "BS.unpack"
                | otherwise   = ""

-- copy and paste from BNFC.Backend.Haskell.CFtoTemplate

rules :: Bool -> Bool -> CF -> String
rules functor pos cf = unlines $

  map (\(s,xs) -> render (case_fun functor pos s (map toArgs xs)) ++++ ifList cf s) $ cf2data cf
 where
   toArgs (cons,_) = (cons, ruleOf cons)
   ruleOf s = maybe undefined id $ lookupRule s (rulesOfCF cf)

-- |
-- >>> case_fun False (Cat "A") [("AA", (Cat "AB", [Right "xxx"]))]
-- instance Print A where
--   prt i e = case e of
--     AA -> prPrec i 0 (concatD [doc (showString "xxx")])
--
-- >>> case_fun False (Cat "Expr") [("EInt", (CoercCat "Expr" 2, [Left (TokenCat "Integer")])), ("EPlus", (CoercCat "Expr" 1, [Left (Cat "Expr"), Right "+", Left (Cat "Expr")]))]
-- instance Print Expr where
--   prt i e = case e of
--     EInt n -> prPrec i 2 (concatD [prt 0 n])
--     EPlus expr0 expr -> prPrec i 1 (concatD [prt 0 expr0, doc (showString "+"), prt 0 expr])
--
-- If the AST is a functor, ignore first argument
-- >>> case_fun True (Cat "Expr") [("EInt", (CoercCat "Expr" 2, [Left (TokenCat "Integer")])), ("EPlus", (CoercCat "Expr" 1, [Left (Cat "Expr"), Right "+", Left (Cat "Expr")]))]
-- instance Print (Expr a) where
--   prt i e = case e of
--     EInt _ n -> prPrec i 2 (concatD [prt 0 n])
--     EPlus _ expr0 expr -> prPrec i 1 (concatD [prt 0 expr0, doc (showString "+"), prt 0 expr])
--
-- It skips intertal categories
-- >>> case_fun True (Cat "Expr") [("EInternal", (Cat "Expr", [Left InternalCat, Left (Cat "Expr")]))]
-- instance Print (Expr a) where
--   prt i e = case e of
--     EInternal _ expr -> prPrec i 0 (concatD [prt 0 expr])
case_fun :: Bool -> Bool -> Cat -> [(String, (Cat, [Either Cat String]))] -> Doc
case_fun functor pos cat xs =
    "instance Print" <+> type_ <+> "where"
    $+$ nest 2 ("prt i" <+> "e = case e of" $$ nest 2 (vcat (map pOneCase xs)))
  where
    type_ | functor   = parens (text (show cat) <+> "a")
          | otherwise = text (show cat)
    pOneCase (f, (cat, rhs)) =
      let vars = names (map (checkRes . var) (filter (/=InternalCat) $ lefts rhs)) 0
      in text f <+> (if pos then "_" else empty) <+> (if functor then "_" else empty) <+> hsep vars <+> "->"
      <+> "prPrec i" <+> integer (precCat cat) <+> mkRhs (map render vars) rhs
    names [] _ = []
    names (x:xs) n
      | x `elem` xs = (text x <> int n) : names xs (n+1)
      | otherwise   = text x            : names xs n
    var (ListCat c)  = var c ++ "s"
    var (TokenCat "Ident")   = "id"
    var (TokenCat "Integer") = "n"
    var (TokenCat "String")  = "str"
    var (TokenCat "Char")    = "c"
    var (TokenCat "Double")  = "d"
    var xs        = map toLower $ show xs
    checkRes s
         | s `elem` hsReservedWords = s ++ "'"
         | otherwise                = s

ifList cf cat = mkListRule $ nil cat ++ one cat ++ cons cat where
  nil cat  = ["   [] -> " ++ render (mkRhs [] its) |
                            Rule f c its <- rulesOfCF cf, isNilFun f , normCatOfList c == cat]
  one cat  = ["   [x] -> " ++ render (mkRhs ["x"] its) |
                            Rule f c its <- rulesOfCF cf, isOneFun f , normCatOfList c == cat]
  cons cat = ["   x:xs -> " ++ render (mkRhs ["x","xs"] its) |
                            Rule f c its <- rulesOfCF cf, isConsFun f , normCatOfList c == cat]
  mkListRule [] = ""
  mkListRule rs = unlines $ ("  prtList" +++ "es = case es of"):rs


-- |
-- >>> mkRhs ["expr1", "n", "expr2"] [Left (Cat "Expr"), Right "-", Left (TokenCat "Integer"), Left (Cat "Expr")]
-- (concatD [prt 0 expr1, doc (showString "-"), prt 0 n, prt 0 expr2])
mkRhs :: [String] -> [Either Cat String] -> Doc
mkRhs args its =
    parens ("concatD" <+> brackets (hsep (punctuate "," (mk args its))))
 where
  mk args (Left InternalCat : items) = mk args items
  mk (arg:args) (Left c  : items)    = (prt c <+> text arg) : mk args items
  mk args       (Right s : items)    = ("doc (showString" <+> text (show s) <> ")") : mk args items
  mk _          _                    = []
  prt c = "prt" <+> integer (precCat c)

